// Generated by CoffeeScript 2.3.0
(function() {
  // Mastering JS design patterns

  // single responsibility principle
  // ensure that each class has only one thing for which it has some responsibility

  // class that looks up users from a database should itself not contain functionality to send e-mails to these users.
  // That is too much responsibility.
  // Complex adapters can be replaced with a composite object that will be explored later in this chapter.
  var Admiral, Agg, Archer, Attendee, Bakery, BankAccountManager, BarrelCalc, BasicArmor, BasicBeer, Battle, Bolton, Bread, BringTroopsCommand, CarMaker, Castle, ChainMail, ClerkOfTheCourt, Complaint, ComplaintResolver, CompoundIngredient, CourtSession, DragonBarrelCalculator, DrownedGods, DrownedGodsAdapter, Event, EventEmmiter, FiboIterator, Fibonacci, Fleet, GetCurrentBalance, GetterSetter, GodDeterminant, GodFactory, GoodStandingState, HamiltonianTour, HamiltonianTourOptions, Horse, HouseStark, HumanSacrifice, JudicialSystem, Karstark, King, KingJoffery, KingSuccession, Knight, Lannister, LannisterFactory, LannisterTournamentBuilder, LordInstructions, LordInstructionsCopy, LordTywin, OldGods, OldGodsAdapter, OnHold, OverdrawnState, Parser, Playa, Player, PlayerObserver, Prayer, Prize, RaspberryBeer, Sacrifice, Sale, Sales, SeaGoingVessel, SelectiveNamePrinterVisitor, Ship, ShipAdapter, SimpleIngredient, Soldier1, Soldier2, Soothsayer, Spy, Statek, SupplyCoordinator, TaxCollector, Tournament, TournamentBuilder, Transportation, TravelResult, Universe1, Universe2, Walk, Westeros, WorldState, WorldStateProvider, after, ag, amIHappy, armor, asia, askMe_1, askMe_2, auto, auto_2, b, bakery, barrel, battleText, bb, children, clone, cloneCoffee, collection, corolla, courtSession1, cr, currentMoney, egg, euroasia, f150, fib, fs, gameObserver, god, god2, god3, gods, i, itemz, j, jamie, joe, k, king, l, len, len1, len2, log, makePublisher, mediator, milk, milkyRicePudding, myEvent, n, numFile, o, p, paper, peasants, pl, prejer, projectionFunc, proxy, pry, publisher, publisherObserver, ras, readline, religion, rice, ricePudding, s, sales, scoreboard, scoreboardObserver, server, ship, showOff_1, showOff_2, simpleCommand, soldier21, soldier22, sp, strFile, strat, sugar, taxCal, theTournament, tour, tournamentB, travelResult, tyrion, uni1, uni2, uni3, uni4, v, visitor, watery, willGetReward,
    hasProp = {}.hasOwnProperty;

  log = console.log.bind(console);

  fs = require('fs');

  numFile = './numbers.txt';

  strFile = './string.txt';

  EventEmmiter = require('events');

  server = require('http').createServer();

  pry = require('pry');

  after = function(ms, fn) {
    return setTimeout(fn, ms);
  };

  // modules
  // attach an object to the global namespace

  // Creational Patterns   **************************************************************************************

  // Westeros = {}
  // or better
  Westeros = Westeros || {};

  Castle = class Castle {
    constructor(name) {
      this.name = name;
    }

  };

  // słowo kluczowe new, które tworzy obiekty na podstawie funkcji konstruujących
  Westeros.Castle = Castle;

  Westeros.castle = new Westeros.Castle('castle tomek');

  log(Westeros.castle.name);

  for (i in Westeros) {
    log(i, "::", Westeros[i]);
  }

  // first check if the object already exists, and use that version instead of reassigning the variable.
  // This allows you to spread your definitions over a number of files - define a single class in each
  // file and then bring them all together as part of the build process

  // Abstract Factory -> concrete factories -> products
  KingJoffery = class KingJoffery {};

  KingJoffery.prototype.makeDecision = function() {
    return log('decision made by king Joffery');
  };

  KingJoffery.prototype.marry = function() {};

  // for i of KingJoffery
  //   log "king Joffery i is: #{i}"
  LordTywin = class LordTywin {};

  LordTywin.prototype.makeDecision = function() {
    return log('decision made by hand lord Tywin');
  };

  // concrete factory method
  LannisterFactory = class LannisterFactory {};

  LannisterFactory.prototype.getKing = function() {
    return new KingJoffery();
  };

  LannisterFactory.prototype.getHandOfTheKing = function() {
    return new LordTywin();
  };

  // # for different family it looks like this:
  // class DiffFamilyFactory
  // DiffFamilyFactory::getKing = ->
  //   new DiffFamilyKing()
  // DiffFamilyFactory::getHandOfTheKing = ->
  //   new DiffFamilyHandOfKing()

  // use
  CourtSession = class CourtSession {
    constructor(abstractFactory, complaintThreshold = 10) {
      this.abstractFactory = abstractFactory;
      this.complaintThreshold = complaintThreshold;
    }

  };

  CourtSession.prototype.complaintPresented = function(complaint) {
    log(complaint);
    if (complaint.severity < this.complaintThreshold) {
      return this.abstractFactory.getHandOfTheKing().makeDecision();
    } else {
      return this.abstractFactory.getKing().makeDecision();
    }
  };

  courtSession1 = new CourtSession(new LannisterFactory, 7);

  // courtSession2 = new CourtSession(new DiffFamilyFactory, 15)
  log(`courtSession1 complainThreshold is ${courtSession1.complaintThreshold}`);

  courtSession1.complaintPresented({
    severity: 8
  });

  courtSession1.complaintPresented({
    severity: 12
  });

  // Builder
  Event = class Event {
    constructor(name) {
      this.name = name;
    }

  };

  Westeros.Event = Event;

  Prize = class Prize {
    constructor(name) {
      this.name = name;
    }

  };

  Westeros.Prize = Prize;

  Attendee = class Attendee {
    constructor(name) {
      this.name = name;
    }

  };

  Westeros.Attendee = Attendee;

  Tournament = class Tournament {
    constructor(events, attendees, prizes) {
      this.events = [];
      this.attendees = [];
      this.prizes = [];
    }

  };

  Westeros.Tournament = Tournament;

  LannisterTournamentBuilder = class LannisterTournamentBuilder {};

  LannisterTournamentBuilder.prototype.build = function() {
    var tournament;
    tournament = new Tournament;
    tournament.events.push(new Event('Joust'));
    tournament.events.push(new Event('Melee'));
    tournament.attendees.push(new Attendee('Jim'));
    tournament.prizes.push(new Prize('gold medal'));
    tournament.prizes.push(new Prize('silver medal'));
    return log(tournament);
  };

  Westeros.LannisterTournamentBuilder = LannisterTournamentBuilder;

  TournamentBuilder = class TournamentBuilder {};

  TournamentBuilder.prototype.build = function(builder) {
    return builder.build();
  };

  Westeros.TournamentBuilder = TournamentBuilder;

  tournamentB = new Westeros.TournamentBuilder();

  log(tournamentB);

  theTournament = tournamentB.build(new Westeros.LannisterTournamentBuilder());

  log(theTournament);

  // Factory Method   *****************************************   *******************************************
  religion = require('./religion');

  ({watery} = require('./religion'));

  log(religion);

  log(watery);

  log(religion.watery);

  GodFactory = class GodFactory {};

  GodFactory.prototype.build = function(godName) {
    if (godName === 'watery') {
      return new religion.watery();
    } else if (godName === 'ancient') {
      return new religion.ancient();
    } else {
      return new religion.DefaultGods();
    }
  };

  GodDeterminant = class GodDeterminant {
    constructor(religion1, prayerPurpose) {
      this.religion = religion1;
      this.prayerPurpose = prayerPurpose;
    }

  };

  Prayer = class Prayer {};

  Prayer.prototype.pray = function(godName) {
    var p;
    p = new GodFactory;
    return p.build(godName).prayTo();
  };

  god = new GodFactory;

  asia = god.build('watery');

  log(asia);

  log(asia.name());

  euroasia = god.build('ancient');

  log(asia.prayTo());

  log(euroasia.prayTo());

  prejer = new Prayer;

  prejer.pray('watery');

  // polish book example
  CarMaker = class CarMaker {};

  CarMaker.prototype.drive = function() {
    return log(`Brum, I have ${this.doors} doors`);
  };

  CarMaker.factory = function(type) {
    var constr, newCar;
    constr = type;
    if (typeof CarMaker[constr] !== "function") {
      throw {
        name: 'Error',
        message: `${constr} nie istnieje`
      };
    }
    // log "Error #{constr} nie istnieje"
    if (typeof CarMaker[constr].prototype.drive !== "function") {
      CarMaker[constr].prototype = new CarMaker;
    }
    newCar = new CarMaker[constr];
    return newCar;
  };

  CarMaker.Compact = function() {
    return this.doors = 4;
  };

  CarMaker.SUV = function() {
    return this.doors = 7;
  };

  log(CarMaker);

  auto = new CarMaker;

  auto_2 = CarMaker;

  log(`to jest auto: ${auto}`);

  log(`to jest auto_2: ${auto_2}`);

  for (i in auto) {
    v = auto[i];
    log(i, " :: ", v);
  }

  for (i in auto_2) {
    v = auto_2[i];
    log(i, " :: ", v);
  }

  corolla = CarMaker.factory('Compact');

  log(corolla);

  corolla.drive();

  // expedition = new CarMaker.factory('suv')
  f150 = auto_2.factory('SUV');

  f150.drive();

  o = new Object();

  n = new Object(1);

  s = Object('1');

  b = Object(true);

  log(o.constructor === Object);

  log(n.constructor === Number);

  log(s.constructor === String);

  log(b.constructor === Boolean);

  // Prototype pattern page 79

  //   *************************************************   ***************************************************
  //   Copying existing objects
  clone = function(source, destination) {
    var attr, results1;
    results1 = [];
    for (attr in source.prototype) {
      results1.push(destination.prototype[attr] = source.prototype[attr]);
    }
    return results1;
  };

  cloneCoffee = function(s, d) {
    var attr, results1;
    results1 = [];
    for (attr in s.prototype) {
      results1.push(d.prototype.attr = s.prototype.attr);
    }
    return results1;
  };

  Lannister = (function() {
    //   *************************************************   ***************************************************
    class Lannister {};

    Lannister.prototype.clone = function() {
      var attr;
      clone = new Lannister;
      for (attr in this) {
        clone[attr] = this[attr];
      }
      return clone;
    };

    return Lannister;

  }).call(this);

  jamie = new Lannister;

  jamie.swordSkills = 9;

  jamie.charm = 6;

  jamie.wealth = 10;

  tyrion = jamie.clone();

  tyrion.charm = 10;

  log(`tyrion wealth is cloned and = ${tyrion.wealth}`);

  // Singleton book pl str 139
  Universe1 = function() { // class Universe
    if (typeof Universe1.instance === 'object') {
      return Universe1.instance;
    }
    this.start_time = 0;
    this.big_bang = 'wielki';
    return Universe1.instance = this;
  };

  uni1 = new Universe1;

  uni2 = new Universe1;

  log(`uni1 is uni2 ${uni1 === uni2}`);

  log(Universe1.instance);

  log(Universe1);

  Universe2 = function() {
    var instance;
    instance = this;
    this.start_time = 1;
    this.big_bang = 'duży';
    return Universe2 = function() {
      return instance;
    };
  };

  // uni5 = new Universe2 - # drugie i następne wywołania wykonują już zmieniony konstruktor
  // jest to wzorzec samomodyfikującej się funkcji :: WADA :: nadpisana funkcja utraci wszystkie właściwości
  // dodane między jej zdefiniowaniem i nadpisaniem
  uni3 = new Universe2;

  uni4 = new Universe2;

  log(`uni3 is uni4 ${uni3 === uni4}`);

  // Universe3 = ->
  //   Universe3 = -> instance
  //   Universe3.prototype = @
  //   instance = new Universe3
  //   instance.constructor = Universe3
  //   instance.start_time = 2
  //   instance.big_bang = 'ogromny'
  //   instatnce

  // Universe3::nothing = true
  // uni6 = new Universe3
  // Universe3::everything = true
  // uni7 = new Universe3
  // log "uni6 is uni7 #{uni6 is uni7}"

  // Structural Patterns   *************************************   simple ways in which objects can interact

  // Adapter pattern   *****************************************  p.84  *******************************************

  // We may need to make use of a class that does not perfectly fit the required interface.
  // The class may be missing methods or may have additional methods we would like to hide.
  // When building library code, adapters can be used to mask the internal method and only present the limited functions needed by the end user.
  // ShipAdapter is simplified version of Ship interface
  Ship = class Ship {
    SetRudderAngleTo(angle) {
      return log(angle);
    }

    SetSailConfiguration(configuration) {}

    SetSailAngle(sailId, sailAngle) {
      return log(sailId, sailAngle);
    }

    GetCurrentBearing() {
      return 7;
    }

    GetCurrentSpeedEstimate() {
      return 7;
    }

    ShiftCrewWeightTo(weightToShift, locationId) {}

  };

  ShipAdapter = (function() {
    ShipAdapter = class ShipAdapter {
      constructor(ship) {
        this.ship = new Ship;
      }

      TurnLeft() {
        this.ship.SetRudderAngleTo(-30);
        return this.ship.SetSailAngle(3, 12);
      }

      TurnRight() {
        this.ship.SetRudderAngleTo(30);
        return this.ship.SetSailAngle(5, -9);
      }

    };
    ShipAdapter.prototype.GoForward = function() {
      return log("ship goes forward");
    };
    return ShipAdapter;
  })();

  ship = new ShipAdapter;

  ship.GoForward();

  log(ship.TurnRight());

  for (i in ship) {
    v = ship[i];
    log(i, " :: ", v);
  }

  // Bridge pattern   *****************************************  p.88  *******************************************
  OldGods = class OldGods {};

  OldGods.prototype.prayTo = function(sacrifice) {
    return log("we old gods hear your prayer");
  };

  DrownedGods = class DrownedGods {};

  DrownedGods.prototype.prayTo = function(humanSacrifice) {
    return log("we drowned gods hear your prayer");
  };

  OldGodsAdapter = class OldGodsAdapter {
    constructor(oldGods) {
      this.oldGods = new OldGods;
    }

  };

  OldGodsAdapter.prototype.prayTo = function() {
    var sacrifice;
    sacrifice = new Sacrifice;
    return this.oldGods.prayTo(sacrifice);
  };

  DrownedGodsAdapter = class DrownedGodsAdapter {
    constructor(drownedGods) {
      this.drownedGods = new DrownedGods;
    }

    drownedGodsProps() {
      var results1;
      results1 = [];
      for (i in this.drownedGods) {
        results1.push(log(`drownedGodsProps are: ${i}`));
      }
      return results1;
    }

  };

  DrownedGodsAdapter.prototype.prayTo = function() {
    var sacrifice;
    sacrifice = new HumanSacrifice;
    return this.drownedGods.prayTo(sacrifice);
  };

  Sacrifice = (function() {
    class Sacrifice {};

    log("we sacrifice");

    return Sacrifice;

  }).call(this);

  HumanSacrifice = (function() {
    class HumanSacrifice {};

    log("we sacrifice humans");

    return HumanSacrifice;

  }).call(this);

  god2 = new DrownedGodsAdapter;

  god2.drownedGodsProps();

  for (i in god2) {
    v = god2[i];
    log(i, v);
  }

  god2.prayTo();

  god3 = new OldGodsAdapter;

  gods = [god2, god3];

// code uses the bridges to provide a consistent interface to the gods so that they can all be treated as equals.
// wywołuje prayTo tak samo dla każdego god, a sygnatura (input , output) jest w definicji, a nie jako argument.
// wrapping the individual gods and proxying method calls through to them.
  for (j = 0, len = gods.length; j < len; j++) {
    god = gods[j];
    god.prayTo();
  }

  // Composite Pattern   *****************************************   *******************************************
  SimpleIngredient = class SimpleIngredient {
    constructor(name, calories, ironContent, vitaminContent) {
      this.name = name;
      this.calories = calories;
      this.ironContent = ironContent;
      this.vitaminContent = vitaminContent;
    }

  };

  SimpleIngredient.prototype.GetName = function() {
    return this.name;
  };

  SimpleIngredient.prototype.GetCalories = function() {
    return this.calories;
  };

  SimpleIngredient.prototype.GetIronContent = function() {
    return this.ironContent;
  };

  SimpleIngredient.prototype.GetVitaminContent = function() {
    return this.vitaminContent;
  };

  CompoundIngredient = class CompoundIngredient {
    constructor(name, ingredients) {
      this.name = name;
      this.ingredients = new Array;
    }

  };

  CompoundIngredient.prototype.AddIngredient = function(ingredient) {
    return this.ingredients.push(ingredient);
  };

  CompoundIngredient.prototype.GetName = function() {
    return this.name;
  };

  CompoundIngredient.prototype.GetCalories = function() {
    var ingredient, k, len1, ref, total;
    total = 0;
    ref = this.ingredients;
    for (k = 0, len1 = ref.length; k < len1; k++) {
      ingredient = ref[k];
      log(`this ingredient is ${ingredient.GetName()}`);
      // for k of ingredient
      //   log k
      total += ingredient.GetCalories();
    }
    return total;
  };

  CompoundIngredient.prototype.GetIronContent = function() {
    var k, len1, ref, total;
    total = 0;
    ref = this.ingredients;
    for (k = 0, len1 = ref.length; k < len1; k++) {
      i = ref[k];
      total += i.GetIronContent();
    }
    return total;
  };

  CompoundIngredient.prototype.GetVitaminContent = function() {
    var k, len1, ref, total;
    total = 0;
    ref = this.ingredients;
    for (k = 0, len1 = ref.length; k < len1; k++) {
      i = ref[k];
      total += i.GetVitaminContent();
    }
    return total;
  };

  CompoundIngredient.prototype.getArr = function() {
    return log(this.ingredients);
  };

  egg = new SimpleIngredient("Egg", 155, 6, 0);

  milk = new SimpleIngredient("Milk", 42, 0, 0);

  sugar = new SimpleIngredient("Sugar", 387, 0, 0);

  rice = new SimpleIngredient("Rice", 370, 8, 0);

  ricePudding = new CompoundIngredient('Rice Pudding');

  ricePudding.AddIngredient(egg);

  ricePudding.AddIngredient(rice);

  ricePudding.AddIngredient(milk);

  ricePudding.AddIngredient(sugar);

  ricePudding.getArr();

  log(`A serving of rice pudding contains: ${ricePudding.GetCalories()} calories`);

  // both the simple and compound version of the ingredients have the same interface (names of functions),
  // the caller does not need to know that there is any difference between the two ingredient types
  // czyli jak GetName is called on simpleI to zwraca co innego i jak jest called  on compoundI co innego
  milkyRicePudding = new CompoundIngredient('milky rice pudding');

  milkyRicePudding.AddIngredient(milk);

  milkyRicePudding.AddIngredient(ricePudding);

  milkyRicePudding.getArr();

  log(`A serving of milky rice pudding contains: ${milkyRicePudding.GetCalories()} calories`);

  // Decorator Pattern   *****************************************   *******************************************
  // str 145 PL
  Sales = class Sales {
    constructor(price) {
      this.price = price || 100;
    }

  };

  Sales.prototype.getPrice = function() {
    return this.price;
  };

  Sales.decorators = {};

  Sales.decorators.fedTax = {
    getPrice: function() {
      var price;
      price = this.uber.getPrice();
      price += price * 5 / 100;
      return price;
    }
  };

  Sales.decorators.quebec = {
    getPrice: function() {
      var price;
      price = this.uber.getPrice();
      price += price * 7.5 / 100;
      return price;
    }
  };

  Sales.decorators.money = {
    getPrice: function() {
      return `USD ${this.uber.getPrice().toFixed(2)}`;
    }
  };

  Sales.decorators.cad = {
    getPrice: function() {
      return "CAD " + this.uber.getPrice().toFixed(2);
    }
  };

  Sales.prototype.decorate = function(decorator) {
    var F, newObj, overrides, results1;
    F = function() {};
    overrides = this.constructor.decorators[decorator];
    F.prototype = this;
    newObj = new F;
    newObj.uber = F.prototype;
// hasOwn = Object::hasOwnProperty
    results1 = [];
    for (i in overrides) {
      if (overrides.hasOwnProperty(i)) {
        results1.push(newObj[i] = overrides[i]);
      } else {
        results1.push(void 0);
      }
    }
    return results1;
  };

  // for i of overrides
  //   if hasOwn.call(overrides, i)
  //     newObj[i] = overrides[i]
  // newObj

  // # konstruktor tymczasowy
  // class Parent
  //   constructor: (name) ->
  //     @name = name or 'Adam'

  // Parent::say = -> log @name

  // class Child extends Parent
  //   constructor: () ->
  //     super('super Adam')

  // inherit_2 = (C, P) ->
  //   F = ->
  //   do (C, P) ->
  //     F.prototype = P.prototype
  //     C.prototype = new F()
  //     C.uber = P.prototype
  //     C.prototype.constructor = C
  //     for i,v of C
  //       log i, " :: ", v

  // inherit_2(Child, Parent)

  // implementacja:
  sales = new Sales;

  log(sales.decorate('fedTax'));

  log(sales.getPrice());

  // v2
  Sale = class Sale {
    constructor(price, decorators_list) {
      this.price = price || 100;
      this.decorators_list = [];
    }

  };

  Sale.decorators = {};

  Sale.decorators.fedTax = {
    getPrice: function(price) {
      return price + price * 5 / 100;
    }
  };

  Sale.decorators.quebec = {
    getPrice: function(price) {
      return price + price * 7.5 / 100;
    }
  };

  Sale.decorators.money = {
    getPrice: function() {
      return `USD ${this.uber.getPrice().toFixed(2)}`;
    }
  };

  Sale.decorators.cad = {
    getPrice: function() {
      return "CAD " + this.uber.getPrice().toFixed(2);
    }
  };

  Sale.prototype.decorate = function(decorator) {
    return this.decorators_list.push(decorator);
  };

  Sale.prototype.getPrice = function() {
    var k, len1, price, ref;
    price = this.price;
    ref = this.decorators_list;
    for (k = 0, len1 = ref.length; k < len1; k++) {
      i = ref[k];
      price = Sale.decorators[i].getPrice(price);
    }
    return price;
  };

  s = new Sale(50);

  s.decorate('fedTax');

  log(s.getPrice());

  // The decorator pattern is a valuable pattern for scenarios where inheritance is too
  // limiting. These scenarios still exist in JavaScript so the pattern remains useful.
  // page 97
  BasicArmor = class BasicArmor {};

  BasicArmor.prototype.CalculateDamageFromHit = function(hit) {
    return hit.Strength * .2;
  };

  BasicArmor.prototype.GetArmorIntegrity = function() {
    return 1;
  };

  ChainMail = class ChainMail {
    constructor(decoratedArmor) {
      this.decoratedArmor = decoratedArmor;
    }

  };

  ChainMail.prototype.CalculateDamageFromHit = function(hit) {
    hit.Strength = hit.Strength * .8;
    return this.decoratedArmor.CalculateDamageFromHit(hit);
  };

  ChainMail.prototype.GetArmorIntegrity = function() {
    return .9 * this.decoratedArmor.GetArmorIntegrity();
  };

  armor = new ChainMail(new BasicArmor());

  for (i in armor) {
    v = armor[i];
    log(i, " :: ", v);
  }

  log(armor.CalculateDamageFromHit({
    Location: "head",
    Weapon: "Sock filled with pennies",
    Strength: 12
  }));

  // Facade Pattern   *****************************************   *******************************************
  // page 100
  Statek = class Statek {};

  Statek.prototype.TurnLeft = function() {};

  Statek.prototype.TurnRight = function() {};

  Statek.prototype.GoFwd = function() {};

  Transportation = {};

  Transportation.Statek = Statek;

  Admiral = class Admiral {};

  Transportation.Admiral = Admiral;

  SupplyCoordinator = class SupplyCoordinator {};

  Transportation.SupplyCoordinator = SupplyCoordinator;

  // Facade:
  Fleet = class Fleet {};

  Fleet.prototype.setDestination = function(destination) {};

  // pass commands to a series of ships, admirals and whoever else needs it
  Fleet.prototype.resupply = function() {};

  Fleet.prototype.attack = function(destination) {};

  // attack a city

  // Fasada str 152
  // ma za zadanie zapewnić alternatywny interfejs obiektu:
  // istnieją pewne metody dodatkowe łączące w sobie wywołania kilku innych metod

  // • stopPropagation() — zapobiega wykonywaniu obsługi zdarzenia w węzłach nadrzędnych;
  // • preventDefault() — zapobiega wykonaniu przez przeglądarkę domyślnej akcji dla zdarzenia

  // fasada która wykona je obie:
  myEvent = {
    stop: function(e) {
      e.stopPropagation();
      return e.preventDefault();
    }
  };

  // myevent = {
  // stop: (e) ->
  //   # inne przeglądarki:
  //   if (typeof e.preventDefault === "function")
  //     e.preventDefault()
  //   if (typeof e.stopPropagation === "function")
  //     e.stopPropagation()
  //   # IE:
  //   if (typeof e.returnValue === "boolean")
  //     e.returnValue = false
  //   if (typeof e.cancelBubble === "boolean")
  //     e.cancelBubble = true

  // Flyweight Pattern   *****************************************   *******************************************
  // page 102

  // którego celem jest zmniejszenie wykorzystania pamięci poprzez poprawę efektywności obsługi dużych obiektów
  // zbudowanych z wielu mniejszych elementów poprzez współdzielenie wspólnych małych elementów.
  // Pattern is used in instances when there is a large number of instances of objects which only vary slightly
  // Flyweight offers a way to compress this data, by only keeping track of the values that differ from some prototype in each instance
  Soldier1 = class Soldier1 {
    constructor(Health, FightAbility, Hunger) {
      this.Health = 10;
      this.FightAbility = 5;
      this.Hunger = 0;
    }

  };

  // JavaScript's prototype model is ideal for this scenario. We can simply assign the most common value
  // to the prototype and have individual instances override them as needed.
  Soldier2 = class Soldier2 {};

  Soldier2.prototype.Health = 100;

  Soldier2.prototype.FightAbility = 50;

  Soldier2.prototype.Hunger = 10;

  soldier21 = new Soldier2;

  soldier22 = new Soldier2;

  log(`soldier21 health is: ${soldier21.Health}`);

  soldier21.Health = 70;

  log(`soldier21 health is: ${soldier21.Health}`);

  log(`soldier22 health is: ${soldier22.Health}`);

  delete soldier21.Health;

  log(`soldier21 health is: ${soldier21.Health}`);

  // Proxy Pattern   *****************************************   *******************************************
  // provides a method of controlling the creation and use of expensive objects
  // page 104

  // lazy instantiation:
  // proxy can check its internal instance, and if not yet initiated, create it before passing on the method call
  BarrelCalc = class BarrelCalc {};

  BarrelCalc.prototype.CalculateNumberNeeded = function(vol) {
    log(vol);
    return Math.ceil(vol / 357);
  };

  DragonBarrelCalculator = class DragonBarrelCalculator {};

  DragonBarrelCalculator.prototype.CalculateNumberNeeded = function(vol) {
    if (this._barrelCalculator == null) {
      this._barrelCalculator = new BarrelCalc;
    }
    //log @_barrelCalculator.CalculateNumberNeeded(714)
    return this._barrelCalculator.CalculateNumberNeeded(vol * .77);
  };

  barrel = new DragonBarrelCalculator;

  log(`barrels: ${barrel.CalculateNumberNeeded(4100)}`);

  // Pośrednik  str 153 PL   *******************

  // Jeden obiekt stanowi interfejs dla innego obiektu
  // Pośrednik znajduje się między użytkownikiem a obiektem i broni - staje się strażnikiem rzeczywistego obiektu,
  // stara się, by ten wykonał jak najmniej pracy
  // służy do poprawy wydajności

  // # JQuery shit:
  // $ = (id) -> document.getElementById(id)

  // $('vids').onclick = (e) ->
  //   e = e or window.event
  //   src = e.target or e.srcElement
  //   return if src.nodeName isnt "A"
  //   e.preventDefault() if typeof e.preventDefault is "function"
  //   e.returnValue = false;
  //   id = src.href.split('--')[1];
  //   src.parentNode.innerHTML = videos.getPlayer(id) if src.className is "play"
  //   src.parentNode.id = "v" + id
  //   videos.getInfo(id)

  // $('toggle-all').onclick = (e) ->
  //   hrefs = $('vids').getElementsByTagName('a')
  //   for i in hrefs
  //     continue if i.className is "play"
  //     continue if !i.parentNode.firstChild.checked
  //     id = i.href.split('--')[1]
  //     i.parentNode.id = "v" + id
  //     videos.getInfo(id)

  // videos =
  //   getPlayer: (id) ->
  //   updateList: (data) ->
  //   getInfo: (id) ->
  //     info = $('info' + id)
  //     http.makeRequest([id], "videos.updateList") if !info
  //     if info.style.display is "none"
  //       info.style.display = ''
  //     else
  //       info.style.display = 'none'

  // http =
  //   makeRequest: (ids, callback) ->
  //     url = 'http://query.yahooapis.com/v1/public/yql?q='
  //     sql = 'select * from music.video.id where ids IN ("%ID%")'
  //     format = "format=json"
  //     handler = "callback=" + callback
  //     script = document.createElement('script')
  //     sql = sql.replace('%ID%', ids.join('","'))
  //     sql = encodeURIComponent(sql)
  //     url += sql + '&' + format + '&' + handler
  //     script.src = url
  //     document.body.appendChild(script)

  // Zaprezentowany wcześniej kod działa prawidłowo, ale można go zoptymalizować. Na scenę
  // wkracza obiekt proxy, który przejmuje komunikację między http i videos.
  // W istniejącym kodzie zachodzi tylko jedna zmiana: metoda videos.getInfo() wywołuje
  // metodę proxy.makeRequest() zamiast metody http.makeRequest().
  // proxy.makeRequest(id, videos.updateList, videos)
  // Obiekt pośrednika korzysta z kolejki, w której gromadzi identyfikatory materiałów wideo przekazane w ostatnich 50 ms.
  // Następnie przekazuje wszystkie identyfikatory, wywołując metodę obiektu http i przekazując własną funkcję
  // wywołania zwrotnego, ponieważ videos.updateList() potrafi przetworzyć tylko pojedynczy rekord danych.
  proxy = {
    ids: [],
    delay: 50,
    timeout: null,
    callback: null,
    context: null,
    makeRequest: function(id, callback, context) {
      // dodanie do kolejki
      this.ids.push(id);
      this.callback = callback;
      this.context = context;
      if (!this.timeout) {
        return this.timeout = setTimeout(function() {
          return proxy.flush();
        }, this.delay);
      }
    },
    flush: function() {
      http.makeRequest(this.ids, "proxy.handler");
      // wyczyszczenie kolejki i funkcji czasowej
      this.timeout = null;
      return this.ids = [];
    },
    handler: function(data) {
      var k, len1, ref, results1;
      // pojedynczy materiał wideo
      if (parseInt(data.query.count, 10) === 1) {
        proxy.callback.call(proxy.context, data.query.results.Video);
      }
      ref = data.query.results.Video;
      // kilka materiałów wideo
      results1 = [];
      for (k = 0, len1 = ref.length; k < len1; k++) {
        i = ref[k];
        results1.push(proxy.callback.call(proxy.context, i));
      }
      return results1;
    }
  };

  // Chain of Responsibility Pattern   ***********************   *******************************************
  JudicialSystem = {};

  Complaint = class Complaint {
    constructor(complaintParty, complaintAbout, complaint) {
      this.complaintParty = "";
      this.complaintAbout = "";
      this.complaint = "";
    }

  };

  ClerkOfTheCourt = class ClerkOfTheCourt {};

  ClerkOfTheCourt.prototype.IsAbleToResolveComplaint = function(complanit) {
    return false;
  };

  ClerkOfTheCourt.prototype.ListenToComplaint = function(complaint) {
    return log('this fucker is not able to resolve this complaint');
  };

  JudicialSystem.ClerkOfTheCourt = ClerkOfTheCourt;

  King = class King {};

  King.prototype.IsAbleToResolveComplaint = function(complaint) {
    return true;
  };

  King.prototype.ListenToComplaint = function(complaint) {
    return log('tak jest able to resolve the complaint');
  };

  JudicialSystem.King = King;

  ComplaintResolver = class ComplaintResolver {
    constructor(complaintListeners) {
      this.complaintListeners = new Array;
      this.complaintListeners.push(new ClerkOfTheCourt);
      this.complaintListeners.push(new King);
    }

  };

  ComplaintResolver.prototype.ResolveComplaint = function(complaint) {
    var k, len1, ref, results1;
    ref = this.complaintListeners;
    results1 = [];
    for (k = 0, len1 = ref.length; k < len1; k++) {
      i = ref[k];
      log(i, i.IsAbleToResolveComplaint);
      if (i.IsAbleToResolveComplaint(complaint)) {
        results1.push(i.ListenToComplaint(complaint));
      } else {
        results1.push(void 0);
      }
    }
    return results1;
  };

  cr = new ComplaintResolver;

  cr.ResolveComplaint('tak');

  log('this is fucking Judicial System: ');

  log(JudicialSystem);

  // Command Pattern   *****************************************   *******************************************

  // a method of encapsulating both the parameters to a method and the current object state, and method to be called.
  // Packs up everything needed to call a method at a later date into a nice little package.
  // single point of command execution also allows us to easily add functionality such as undo
  LordInstructions = class LordInstructions {
    constructor(location1, numberOfTroops1, kiedy1) {
      this.location = location1;
      this.numberOfTroops = numberOfTroops1;
      this.kiedy = kiedy1;
    }

  };

  LordInstructions.prototype.BringTroops = function(location, numberOfTroops, kiedy) {
    return log(`You have been instructed to bring ${numberOfTroops} troops to ${location} by ${kiedy}`);
  };

  BringTroopsCommand = class BringTroopsCommand {
    constructor(location1, numberOfTroops1, kiedy1) {
      this.location = location1;
      this.numberOfTroops = numberOfTroops1;
      this.kiedy = kiedy1;
    }

  };

  BringTroopsCommand.prototype.Execute = function() {
    var receiver;
    receiver = new LordInstructions;
    return receiver.BringTroops(this._location, this._numberOfTroops, this._kiedy);
  };

  simpleCommand = new Array();

  simpleCommand.push(new LordInstructions().BringTroops);

  simpleCommand.push("King's Landing");

  simpleCommand.push(500);

  simpleCommand.push(new Date());

  log(simpleCommand[0](simpleCommand[1], simpleCommand[2], simpleCommand[3]));

  // the invoker   ***********************************
  // part of the command pattern that instructs the command to execute its instructions - triggers invocation
  process.nextTick(function() {
    var BTC;
    BTC = new BringTroopsCommand;
    return BTC.Execute();
  });

  // The process.nextTick function defers the execution of a command to the end of
  // the event loop such that it is executed next time the process has nothing to do.

  // the receiver   **********************************
  // This is the target of the command execution.
  // The receiver knows how to perform the action that the command has deferred.
  // There need not be anything special about the receiver; in fact it may be any class.
  LordInstructionsCopy = class LordInstructionsCopy {
    constructor(location1, numberOfTroops1, kiedy1) {
      this.location = location1;
      this.numberOfTroops = numberOfTroops1;
      this.kiedy = kiedy1;
    }

  };

  LordInstructionsCopy.prototype.BringTroops = function(location, numberOfTroops, kiedy) {
    return log(`You have been instructed to bring ${numberOfTroops} troops to ${location} by ${kiedy}`);
  };

  // Together these components make up the command pattern. A client will generate a
  // command and pass it off to an invoker that may delay the command or execute it at
  // once and the command will act upon a receiver.

  // # building undo stack:
  // In the case of building an undo stack, the commands are special, in that they have
  // both an Execute and an Undo method. One takes the application state forward and
  // the other backward. To perform an undo, simply pop the command off the undo
  // stack, execute the Undo function, and push it onto a redo stack. For redo, pop from
  // redo, run Execute, and push to the undo stack. Simple as that, although one must
  // make sure all state mutations are performed through commands.

  // Interpreter Pattern   *****************************************   *******************************************
  Battle = class Battle {
    constructor(battleGround, agressor, defender, victor) {
      this.battleGround = battleGround;
      this.agressor = agressor;
      this.defender = defender;
      this.victor = victor;
    }

  };

  Parser = class Parser {
    constructor(battleText1, currentIndex, battleList) {
      this.battleText = battleText1;
      this.currentIndex = 0;
      this.battleList = battleText.split("\n");
    }

  };

  Parser.prototype.nextBattle = function() {
    var segments;
    if (!this.battleList[0]) {
      return null;
    }
    segments = this.battleList[0].match(/\((.+?)\s?->\s?(.+?)\s?<-\s?(.+?)\s?->\s?(.+)/);
    return new Battle(segments[2], segments[1], segments[3], segments[4]);
  };

  battleText = "(Robert Baratheon -> River Trident <- RhaegarTargaryen) -> Robert Baratheon";

  p = new Parser(battleText);

  log(p.nextBattle());

  // This data structure can now be queried like one would for any other structure in JavaScript

  // Interator Pattern   *****************************************   *******************************************
  KingSuccession = class KingSuccession {
    constructor(inlineForThrone, pointer) {
      this.inlineForThrone = inlineForThrone;
      this.pointer = 0;
    }

  };

  KingSuccession.prototype.next = function() {
    return this.inlineForThrone[this.pointer++];
  };

  king = new KingSuccession(["Robert Baratheon", "JofferyBaratheon", "TommenBaratheon"]);

  log(king);

  log(king.next());

  log(king.next());

  FiboIterator = class FiboIterator {
    constructor(previous, beforePrevious) {
      this.previous = 1;
      this.beforePrevious = 1;
    }

  };

  FiboIterator.prototype.next = function() {
    var current;
    current = this.previous + this.beforePrevious;
    log("***");
    log(`current is: ${current} cos beforePrevious_1 is: ${this.beforePrevious} and previous_1 is: ${this.previous}`);
    this.beforePrevious = this.previous;
    log(`beforePrevious_2 is: ${this.beforePrevious} cos previous_1 is: ${this.previous}`);
    this.previous = current;
    log(`previous_2 is: ${this.previous} cos current is: ${current}`);
    return current;
  };

  fib = new FiboIterator;

  log(fib);

  fib.next();

  fib.next();

  fib.next();

  fib.next();

  Agg = function() {
    var data, index, length;
    index = 0;
    data = [1, 2, 3, 4];
    length = data.length;
    return {
      next: function() {
        var element;
        if (!this.hasNext()) {
          null;
        }
        element = data[index];
        index = index + 1;
        return element;
      },
      hasNext: function() {
        return index < length;
      },
      rewind: function() {
        return index = 0;
      },
      current: function() {
        return log(`current element is: ${data[index]}`);
      }
    };
  };

  ag = new Agg;

  while (ag.hasNext()) {
    log(`Agg next: ${ag.next()}`);
  }

  ag.rewind();

  ag.current();

  // Mediator Pattern   *****************************************   *******************************************

  // str 160 PL

  // ma za zadanie promować luźne powiązania obiektów i wspomóc przyszłą konserwację kodu.
  // niezależne obiekty (koledzy) nie komunikują się ze sobą bezpośrednio, ale korzystają z obiektu mediatora.
  // Gdy jeden z kolegów zmieni stan, informuje o tym mediator, a ten przekazuje tę informację wszystkim innym zainteresowanym kolegom.

  // Mediator wie o wszystkich obiektach. Komunikuje się z urządzeniem wejściowym (klawiaturą),
  // obsługuje naciśnięcia klawiszy, określa, który gracz jest aktywny, i informuje o zmianach
  // wyników. Gracz jedynie gra (czyli aktualizuje swój własny wynik) i informuje
  // mediator o tym zdarzeniu. Mediator informuje tablicę o zmianie wyniku, a ta aktualizuje
  // wyświetlaną wartość. Poza mediatorem żaden inny obiekt nie wie nic o pozostałych.

  // # GRA:
  readline = require('readline');

  readline.emitKeypressEvents(process.stdin);

  process.stdin.setRawMode(true);

  // Obiekty graczy są tworzone przy użyciu konstruktora Player() i zawierają własne właściwości
  // points i name. Metoda play() z prototypu zwiększa liczbę punktów o jeden i informuje
  // o tym fakcie mediator.
  Player = class Player {
    constructor(name, points) {
      this.name = name;
      this.points = 0;
    }

  };

  Player.prototype.play = function() {
    this.points += 1;
    return mediator.played();
  };

  // Obiekt scoreboard zawiera metodę update() wywoływaną przez mediator po zdobyciu
  // punktu przez jednego z graczy. Tablica nie wie nic o graczach i nie przechowuje wyniku —
  // po prostu wyświetla informacje przekazane przez mediator.
  scoreboard = {
    update: function(score) {
      var results1;
      results1 = [];
      for (i in score) {
        if (!hasProp.call(score, i)) continue;
        v = score[i];
        results1.push(log(i, ": ", v));
      }
      return results1;
    }
  };

  // Obiekt mediatora odpowiada za inicjalizację gry oraz utworzenie obiektów graczy
  // w metodzie setup() i śledzenie ich poczynań dzięki umieszczeniu ich we właściwości players.
  // Metoda played() zostaje wywołana przez każdego z graczy po wykonaniu akcji. Aktualizuje ona
  // wynik (score) i przesyła go do tablicy (scoreboard). Ostatnia metoda, keypress(), obsługuje
  // zdarzenia klawiatury, określa, który gracz jest aktywny, i powiadamia go o wykonanej akcji.
  mediator = {
    players: {},
    setup: function() {
      var players;
      players = this.players;
      players.home = new Player('Gospodarze');
      return players.guest = new Player('Goście');
    },
    // ktoś zagrał, uaktualnij wynik
    played: function() {
      var players, score;
      players = this.players;
      score = {
        "Gospodarze": players.home.points,
        "Goście": players.guest.points
      };
      return scoreboard.update(score);
    },
    // obsługa interakcji z użytkownikiem
    keypress: function(key) {
      if (key === '1') {
        mediator.players.home.play();
      }
      if (key === '0') {
        return mediator.players.guest.play();
      }
    }
  };

  // # start!
  // mediator.setup()
  // process.stdin.on 'keypress', (key) ->  mediator.keypress(key)
  // # gra kończy się po 5 sekundach
  // after 2500, () ->
  //   log "koniec gry: Goście #{mediator.players.guest.points} :: Gospodarze #{mediator.players.home.points}"
  //   process.exit()

  // page 122

  // many-to-many relationships
  // mediators are best used when the communication is both complex and well defined
  // if the communication is not complex, then the mediator adds extra complexity.
  // if the communication is ill defined, then it becomes difficult to codify the communication rules in a single place.
  Karstark = class Karstark {
    constructor(greatLord) {
      this.greatLord = greatLord;
    }

  };

  Karstark.prototype.receiveMessage = function(message) {};

  Karstark.prototype.sendMessage = function(message) {
    return this.greatLord.routeMessage(message);
  };

  Bolton = class Bolton {
    constructor(greatLord) {
      this.greatLord = greatLord;
    }

  };

  Bolton.prototype.receiveMessage = function(message) {};

  Bolton.prototype.sendMessage = function(message) {
    return this.greatLord.routeMessage(message);
  };

  // mediator
  HouseStark = class HouseStark {
    constructor(karstark, bolton, frey, umber) {
      this.karstark = new Karstark(this);
      this.bolton = new Bolton(this);
    }

  };

  HouseStark.prototype.receiveMessage = function(message) {};

  // Memento Pattern   *****************************************   *******************************************

  // This world state is used to track all the conditions that make up the world and encompasses the whole state for the application, it can be used as a memento.
  WorldState = class WorldState {
    constructor(numberOfKings1, currentKingInKingsLanding1, season1) {
      this.numberOfKings = numberOfKings1;
      this.currentKingInKingsLanding = currentKingInKingsLanding1;
      this.season = season1;
    }

  };

  // provides the same state as the memento and allows for the creation and restoration of mementos
  WorldStateProvider = class WorldStateProvider {};

  WorldStateProvider.prototype.saveMemento = function() {
    return new WorldState(this.numberOfKings, this.currentKingInKingsLanding, this.season);
  };

  WorldStateProvider.prototype.restoreMemento = function(memento) {
    this.numberOfKings = memento.numberOfKings;
    this.currentKingInKingsLanding = memento.currentKingInKingsLanding;
    return this.season = memento.season;
  };

  Soothsayer = class Soothsayer {
    constructor(startingPoints, currentState) {
      this.startingPoints = [];
      this.currentState = new WorldStateProvider;
    }

  };

  Soothsayer.prototype.setInitialConditions = function(numberOfKings, currentKingInKingsLanding, season) {
    this.currentState.numberOfKings = numberOfKings;
    this.currentState.currentKingInKingsLanding = currentKingInKingsLanding;
    return this.currentState.season = season;
  };

  Soothsayer.prototype.alterNumberOfKingsAndForetell = function(numberOfKings) {
    this.startingPoints.push(this.currentState.saveMemento());
    return this.currentState.numberOfKings = numberOfKings;
  };

  Soothsayer.prototype.alterSeasonAndForetell = function(season) {
    return log(4);
  };

  Soothsayer.prototype.alterCurrentKingInKingsLandingAndForetell = function(currentKingInKingsLanding) {
    return log('T');
  };

  Soothsayer.prototype.tryADifferentChange = function() {
    return this.currentState.restoreMemento(this.startingPoints.pop());
  };

  // Observer Pattern   *****************************************   *******************************************
  GetterSetter = class GetterSetter {};

  GetterSetter.prototype.getProperty = function() {
    return this._property;
  };

  // setter function augmented with a call to some other object that is interested in knowing that a value has changed
  GetterSetter.prototype.setProperty = function(value) {
    var temp;
    temp = this._property;
    this._property = value;
    return this._listener.Event(value, temp);
  };

  Spy = class Spy {
    constructor(_partiesToNotify) {
      this._partiesToNotify = [];
    }

  };

  Spy.prototype.subscribe = function(subscriber) {
    this._partiesToNotify.push(subscriber);
    return log(`parites to Notify: ${this._partiesToNotify}`);
  };

  Spy.prototype.unSubscribe = function(subscriber) {
    return this._partiesToNotify.remove(subscriber);
  };

  Spy.prototype.SetPainKillers = function(painKillers) {
    var k, len1, party, ref, results1;
    this._painKillers = painKillers;
    ref = this._partiesToNotify;
    results1 = [];
    for (k = 0, len1 = ref.length; k < len1; k++) {
      party = ref[k];
      results1.push(party(painKillers));
    }
    return results1;
  };

  Playa = class Playa {};

  Playa.prototype.onKingsMedsAmountChange = function(painKillerAmount) {
    return log(`new Amount of pain Killers is: ${painKillerAmount}`);
  };

  sp = new Spy;

  pl = new Playa;

  // observer pattern can also be applied to methods as well as properties
  sp.subscribe(pl.onKingsMedsAmountChange);

  sp.SetPainKillers(12);

  // Observer in jQuery library:
  // Subscribe to all the click events on buttons on a page with the following line:
  //   $("body").on("click", "button", function(){/*do something*/})
  // Even in Vanilla JavaScript, the same pattern applies:
  //   buttons = document.getElementsByTagName("button")
  //   for btn in buttons
  //     btn.onclick = -> log 'button clicked'

  // strona 163 PL

  // celem używania wzorca jest promowanie luźnego powiązania elementów.
  // Zamiast sytuacji, w której jeden obiekt wywołuje metodę drugiego, mamy sytuację, w której drugi
  // z obiektów zgłasza chęć otrzymywania powiadomień o zmianie w pierwszym obiekcie
  // Subskrybenta nazywa się często obserwatorem, a obiekt obserwowany obiektem publikującym lub źródłem
  // Obiekt publikujący wywołuje subskrybentów po zajściu istotnego zdarzenia i przekazuje informację w postaci np. obiektu zdarzenia

  // paper publikuje gazetę codzienną i miesięcznik
  // subscribers tablica przechowującą wszystkich subskrybentów
  // Gdy zajdzie istotne zdarzenie, obiekt paper przejdzie w pętli przez wszystkich subskrybentów, by ich o nim powiadomić.
  // Notyfikacja polega na wywołaniu metody obiektu subskrybenta = w momencie zgłoszenia chęci otrzymywania powiadomień
  // subskrybent musi przekazać obiektowi paper jedną ze swoich metod w wywołaniu metody subscribe()
  // paper może dodatkowo umożliwić anulowanie subskrypcji, czyli usunięcie wpisu z tablicy subskrybentów
  // istotną metodą obiektu paper jest publish(), która wywołuje metody subskrybentów.

  // • subscribers — tablica
  // • subscribe() — dodaje wpis do tablicy
  // • unsubscribe() — usuwa wpis z tablicy
  // • publish() — przechodzi w pętli przez subskrybentów i wywołuje przekazane przez nich metody.
  // Wszystkie trzy metody potrzebują parametru type, ponieważ wydawca może zgłosić kilka różnych zdarzeń
  // (publikację gazety lub magazynu), a subskrybenci mogą zdecydować się na otrzymywanie powiadomień tylko o jednym z nich.
  publisher = {
    subscribers: {
      any: []
    },
    subscribe: function(fn, type) {
      type = type || 'any';
      if (typeof this.subscribers[type] === 'undefined') {
        this.subscribers[type] = [];
      }
      return this.subscribers[type].push(fn);
    },
    unsubscribe: function(fn, type) {
      return this.visitSubscribers('unsubscribe', fn, type);
    },
    publish: function(publication, type) {
      return this.visitSubscribers('publish', publication, type);
    },
    visitSubscribers: function(action, arg, type) {
      var k, len1, pubtype, results1, sub, subs;
      pubtype = type || 'any';
      subs = this.subscribers[pubtype];
      if (subs) {
        results1 = [];
        for (k = 0, len1 = subs.length; k < len1; k++) {
          sub = subs[k];
          if (action === 'publish') {
            results1.push(sub(arg));
          } else {
            if (sub === arg) {
              results1.push(subs.splice(sub, 1));
            } else {
              results1.push(void 0);
            }
          }
        }
        return results1;
      }
    }
  };

  // funkcja która przyjmuje obiekt i zamienia go w obiekt publikujący przez skopiowanie wszystkich ogólnych metod dotyczących publikacji
  makePublisher = function(o) {
    var results1;
    o.subscribers = {
      any: []
    };
    results1 = [];
    for (i in publisher) {
      if (typeof publisher[i] === 'function') {
        results1.push(o[i] = publisher[i]);
      } else {
        results1.push(void 0);
      }
    }
    return results1;
  };

  // paper, który będzie publikował gazetę i magazyn
  paper = {
    daily: function() {
      // log @publish
      return this.publish("ciekawy news");
    },
    monthly: function() {
      return this.publish("interesującą analizę", "magazyn");
    }
  };

  // robimy z obiektu wydawcę
  makePublisher(paper);

  // subskrybent o nazwie joe
  joe = {
    drinkCoffee: function(paper) {
      return log(`Właśnie przeczytałem ${daily()}`);
    },
    sundayPreNap: function(monthly) {
      return log(`Chyba zasnę, czytając ${monthly()}`);
    }
  };

  //joe zgłasza się jako subskrybent do paper
  publisher.subscribe(joe.drinkCoffee);

  publisher.subscribe(joe.sundayPreNap, 'magazyn');

  log(publisher.subscribers);

  paper.daily();

  paper.monthly();

  // SHIT ABOVE DOES NOT WORK - makePublisher - this subscribers is not the same
  PlayerObserver = class PlayerObserver {
    constructor(name, key1, points, fire) {
      this.name = name;
      this.key = key1;
      this.points = 0;
      this.fire('newplayer', this);
    }

  };

  PlayerObserver.prototype.play = function() {
    this.points += 1;
    return this.fire('play', this);
  };

  scoreboardObserver = {
    update: function(score) {
      var results1;
      results1 = [];
      for (i in score) {
        if (!hasProp.call(score, i)) continue;
        v = score[i];
        results1.push(log(i, ": ", v));
      }
      return results1;
    }
  };

  publisherObserver = {
    subscribers: {
      any: []
    },
    on: function(type, fn, context) {
      type = type || 'any';
      fn = typeof fn === 'function' ? fn : context[fn];
      if (typeof this.subscribers[type] === 'undefined') {
        this.subscribers[type] = [];
      }
      return this.subscribers[type].push({
        fn: fn,
        context: context || this
      });
    },
    remove: function(type, fn, context) {
      return this.visitSubscribers('unsubscribe', type, fn, context);
    },
    fire: function(type, publication) {
      return this.visitSubscribers('publish', type, publication);
    },
    visitSubscribers: function(action, type, arg, context) {
      var pubtype, results1, sub, subs;
      pubtype = type || 'any';
      subs = this.subscribers[pubtype];
      results1 = [];
      for (sub in subs) {
        if (action === 'publish') {
          results1.push(sub.fn.call(sub.context, arg));
        } else {
          if (sub.fn === arg && sub.context === context) {
            results1.push(subs.splice(sub, 1));
          } else {
            results1.push(void 0);
          }
        }
      }
      return results1;
    }
  };

  gameObserver = {
    keys: {},
    addPlayer: function(player) {
      var key;
      key = player.key.toString().charCodeAt(0);
      return this.keys[key] = player;
    },
    handleKeypress: function(key) {
      if (game.keys[key]) {
        game.keys.play();
      }
      if (key === '0') {
        return mediator.players.guest.play();
      }
    },
    handlePlay: function(player) {
      ({
        players: this.keys,
        score: {}
      });
      for (i in players) {
        if (players.hasOwnProperty(i)) {
          score[players[i].name] = players[i].startingPoints;
        }
      }
      return this.fire('scorechange', score);
    }
  };

  // # dynamiczne tworzenie tylu obiektów graczy (po naciśnięciu klawiszy), ile zostanie zażądanych przez grających
  // while 1
  //   playerName = prompt('podaj imię gracza')
  //   break if !playerName
  //   while 1
  //     key = prompt("Klawisz dla gracza #{playerName} ?")
  //     break if key
  //   new Player(playername, key)

  // State Pattern   *****************************************   *******************************************
  // page 131

  // Keeping track of the state is a typical problem in most applications. When the transitions between states is complex,
  // then wrapping it up in a state pattern is one method of simplifying things. It is also possible to build up a simple
  // workflow by registering events as sequential.
  BankAccountManager = class BankAccountManager {
    constructor(currentState) {
      this.currentState = new GoodStandingState(this);
    }

  };

  BankAccountManager.prototype.Deposit = function(amount) {
    return this.currentState.Deposit(amount);
  };

  BankAccountManager.prototype.Withdraw = function(amount) {
    return this.currentState.Withdraw(amount);
  };

  BankAccountManager.prototype.addToBalance = function(amount) {
    return this.balance += amount;
  };

  BankAccountManager.prototype.getBalance = function() {
    return this.balance;
  };

  BankAccountManager.prototype.moveToState = function(newState) {
    return this.currentState = new State;
  };

  GoodStandingState = class GoodStandingState {
    constructor(manager) {
      this.manager = manager;
    }

  };

  GoodStandingState.prototype.Deposit = function(amount) {
    return this.manager.addToBalance(amount);
  };

  GoodStandingState.prototype.Withdraw = function(amount) {
    if (this.manager.getBalance < amount) {
      this.manager.moveToState(new OverdrawnState(this.manager));
    }
    return this.manager.addToBalance(-1 * amount);
  };

  OverdrawnState = class OverdrawnState {
    constructor(manager) {
      this.manager = manager;
    }

  };

  OverdrawnState.prototype.Deposit = function(amount) {
    this.manager.addToBalance(amount);
    if (this.manager.getBalance() > 0) {
      return this.manager.moveToState(new GoodStandingState(this.manager));
    }
  };

  OverdrawnState.prototype.Withdraw = function(amount) {
    this.manager.moveToState(new OnHold(this.manager));
    throw "Cannot withdraw money from an already overdrawn bank account";
  };

  OnHold = class OnHold {
    constructor(manager) {
      this.manager = manager;
    }

  };

  OnHold.prototype.Deposit = function(amount) {
    this.manager.addToBalance(amount);
    throw "Your account is on hold and you must go to the bank to resolve the issue";
  };

  OnHold.prototype.Withdraw = function(amount) {
    throw "Your account is on hold and you must go to the bank to resolve the issue";
  };

  TravelResult = (function() {
    // Strategy Pattern   *****************************************   *******************************************
    // page 135

    // strategy pattern, the method signature for each strategy should be the same
    class TravelResult {
      constructor(durationDays, probabilityOfDeath, cost) {
        this.durationDays = durationDays;
        this.probabilityOfDeath = probabilityOfDeath;
        this.cost = cost;
      }

    };

    log(TravelResult.durationDays, TravelResult.probabilityOfDeath, TravelResult.cost);

    return TravelResult;

  }).call(this);

  SeaGoingVessel = class SeaGoingVessel {};

  SeaGoingVessel.prototype.travel = function(source, destination) {
    return new TravelResult(15, .25, 500);
  };

  Horse = class Horse {};

  Horse.prototype.travel = function(source, destination) {
    return new TravelResult(30, .25, 50);
  };

  Walk = class Walk {};

  Walk.prototype.travel = function(source, destination) {
    return new TravelResult(150, .55, 0);
  };

  GetCurrentBalance = class GetCurrentBalance {
    constructor(bal) {
      this.bal = bal;
    }

  };

  GetCurrentBalance.prototype.getBal = function() {
    return this.bal;
  };

  currentMoney = new GetCurrentBalance(501);

  log(currentMoney.bal);

  if (currentMoney.bal > 500) {
    strat = new SeaGoingVessel;
  } else if (currentMoney.bal > 50) {
    strat = new Horse;
  } else {
    strat = new Walk;
  }

  travelResult = strat.travel();

  log(travelResult);

  // Template Pattern   *****************************************   *******************************************
  // page 138
  BasicBeer = class BasicBeer {
    constructor(name) {
      this.name = name;
    }

    whatsTheName() {
      return log(this.name);
    }

  };

  BasicBeer.prototype.create = function() {
    this.addIngredients();
    this.stir();
    this.ferment();
    this.test();
    if (this.testingPassed()) {
      return this.distribute();
    }
  };

  BasicBeer.prototype.addIngredients = function() {
    throw "Add ingredients needs to be implemented";
  };

  BasicBeer.prototype.stir = function() {
    return log('stiring');
  };

  BasicBeer.prototype.ferment = function() {
    return log('let stand for 30 days');
  };

  BasicBeer.prototype.test = function() {
    return log('drink a cup to taste it');
  };

  BasicBeer.prototype.testingPassed = function() {
    throw "Conditions to pass a test must be implemented";
  };

  BasicBeer.prototype.distribute = function() {
    return log('place beer in 50l casks');
  };

  RaspberryBeer = class RaspberryBeer extends BasicBeer {};

  RaspberryBeer.prototype.addIngredients = function() {
    return log('RaspberryBeer ingredients');
  };

  RaspberryBeer.prototype.testingPassed = function() {
    return log('RaspberryBeer passed the test');
  };

  ras = new RaspberryBeer;

  ras.addIngredients();

  ras.test();

  ras.whatsTheName();

  bb = new BasicBeer('basicBeer');

  bb.whatsTheName();

  Knight = (function() {
    // Template Pattern   *****************************************   *******************************************
    // page 142
    class Knight {};

    Knight._type = 'Knight';

    return Knight;

  }).call(this);

  Knight.prototype.printName = function() {
    return log('Knight');
  };

  Knight.prototype.visit = function(visitor) {
    log(`this is ${this} and ${Knight._type}`);
    return visitor.visit(this);
  };

  Archer = (function() {
    class Archer {};

    Archer._type = 'Archer';

    return Archer;

  }).call(this);

  Archer.prototype.printName = function() {
    return log('Archer');
  };

  Archer.prototype.visit = function(visitor) {
    return visitor.visit(this);
  };

  collection = [];

  collection.push(new Knight);

  collection.push(new Archer);

  for (k = 0, len1 = collection.length; k < len1; k++) {
    i = collection[k];
    if (typeof i === 'Knight') {
      i.printName();
      log('Knight of typeof');
    } else if (i._type === 'Knight') {
      i.printName();
      log('Knight of _type');
    } else if (i instanceof Knight) {
      i.printName();
      log('Knight of an instanceof');
    } else {
      log('not a Knight');
    }
  }

  SelectiveNamePrinterVisitor = class SelectiveNamePrinterVisitor {};

  SelectiveNamePrinterVisitor.prototype.visit = function(memberOfArmy) {
    log(memberOfArmy);
    if (memberOfArmy._type === 'Knight') {
      return this.visitKnight(memberOfArmy);
    } else if (memberOfArmy instanceof Knight) {
      log('visitor knight from the instanceof');
      return this.visitKnight(memberOfArmy);
    } else {
      return log('Not a Knight');
    }
  };

  SelectiveNamePrinterVisitor.prototype.visitKnight = function(memberOfArmy) {
    return memberOfArmy.printName();
  };

  visitor = new SelectiveNamePrinterVisitor;

  for (l = 0, len2 = collection.length; l < len2; l++) {
    i = collection[l];
    i.visit(visitor);
  }

  // DOM i wzorce dotyczące przeglądarek ...171............................................................................

  // Skrypty wykorzystujące DOM ............172
  // Dostęp do DOM .........................173
  // Modyfikacja DOM .......................174
  // Zdarzenia .............................175
  // Obsługa zdarzeń .......................175
  // Delegacja zdarzeń .....................177
  // Długo działające skrypty ..............178
  // Funkcja setTimeout() ..................178
  // Skrypty obliczeniowe ..................179
  // Komunikacja z serwerem ................179
  // Obiekt XMLHttpRequest .................180
  // JSONP .................................181
  // Ramki i wywołania jako obrazy .........184
  // Serwowanie kodu JavaScript klientom ...184
  // Łączenie skryptów .....................184
  // Minifikacja i kompresja ...............185
  // Nagłówek Expires ......................185
  // Wykorzystanie CDN .....................186
  // Strategie wczytywania skryptów ........186
  // Lokalizacja elementu <script> .........187
  // Wysyłanie pliku HTML fragmentami ......188
  // Dynamiczne elementy <script>
  // zapewniające nieblokujące pobieranie ..189
  // Wczytywanie leniwe ....................190
  // Wczytywanie na żądanie ................191
  // Wstępne wczytywanie kodu JavaScript ...192

  // STR 182 zrobić sobie lepsze XO - tuning + smartPlay + beauty => na stronke

  //   *****************************************                          *******************************************
  //   **************************************     FUNCTIONAL PROGRAMMING     ****************************************
  //   *****************************************                          *******************************************
  HamiltonianTourOptions = class HamiltonianTourOptions {
    onTourStart() {
      return log('start tour');
    }

    onEntryToAttraction(cityname) {
      return log(`I'm delighted to be in ${cityname}`);
    }

    onExitFromAttraction() {
      return log('exit attraction');
    }

    onTourCompletion() {
      return log('finish tour');
    }

  };

  HamiltonianTour = class HamiltonianTour {
    constructor(options) {
      this.options = options;
    }

  };

  HamiltonianTour.prototype.StartTour = function() {
    if (this.options.onTourStart && typeof this.options.onTourStart === "function") {
      this.options.onTourStart();
      this.VisitAttraction("King's Landing");
      this.VisitAttraction("Winterfell");
      this.VisitAttraction("Mountains of Dorne");
      this.VisitAttraction("Eyrie");
    }
    if (this.options.onTourCompletion && typeof this.options.onTourCompletion === "function") {
      return this.options.onTourCompletion();
    }
  };

  HamiltonianTour.prototype.VisitAttraction = function(AttractionName) {
    if (this.options.onEntryToAttraction && typeof this.options.onEntryToAttraction === "function") {
      this.options.onEntryToAttraction(AttractionName);
    }
    if (this.options.onExitFromAttraction && typeof this.options.onExitFromAttraction === "function") {
      return this.options.onExitFromAttraction(AttractionName);
    }
  };

  tour = new HamiltonianTour(new HamiltonianTourOptions);

  tour.StartTour();

  // adding a simple filtering method to the array object

  // custom map
  Array.prototype.where = function(inclusionTest) {
    var results;
    results = [];
    i = 0;
    while (i < this.length) {
      if (inclusionTest(this[i])) {
        results.push(this[i]);
      }
      i++;
    }
    return results;
  };

  itemz = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

  log(itemz.where(function(thing) {
    return thing % 2 === 0;
  }).where(function(thing) {
    return thing % 3 === 0;
  }));

  // method of returning a modified version of the original object without changing the original is known as a fluent interface

  // custom filter
  Array.prototype.select = function(projection) {
    var results;
    results = [];
    i = 0;
    while (i < this.length) {
      results.push(projection(this[i]));
      i++;
    }
    return results;
  };

  children = [
    {
      id: 1,
      Name: "Rob"
    },
    {
      id: 2,
      Name: "Sansa"
    },
    {
      id: 3,
      Name: "Arya"
    },
    {
      id: 4,
      Name: "Brandon"
    },
    {
      id: 5,
      Name: "Rickon"
    }
  ];

  children.where(function(x) {
    return x.id % 2 === 0;
  }).select(function(x) {
    return log(x.Name);
  });

  // Accumulators page 158 - jakiś kurwa bezsens [ale chodzi o reduce]
  peasants = [
    {
      name: "Jory Cassel",
      taxesOwed: 11,
      bankBalance: 50
    },
    {
      name: "Vardis Egen",
      taxesOwed: 5,
      bankBalance: 20
    }
  ];

  projectionFunc = function(item) {
    return Math.min(item.taxesOwed, item.bankBalance);
  };

  TaxCollector = class TaxCollector {};

  TaxCollector.prototype.collect = function(items, value, projection) {
    if (items.length > 1) {
      projection(items[0]) + this.collect(items.slice(1), value, projection);
    }
    return projection(items[0]);
  };

  taxCal = new TaxCollector;

  log(taxCal.collect(peasants, 2, projectionFunc));

  // Memoization page 160
  // memoization is a specific term to retain a number of previously calculated values from a function
  Fibonacci = class Fibonacci {
    constructor(memoizedValues) {
      this.memoizedValues = [];
    }

  };

  Fibonacci.prototype.naiveFibo = function(n) { // n = index liczby w ciągu fibonacciego np. 8th liczba w ciągu to 21
    if (n === 0) {
      return 0;
    }
    if (n <= 2) {
      return 1;
    }
    return this.naiveFibo(n - 1) + this.naiveFibo(n - 2);
  };

  Fibonacci.prototype.memoizedFibo = function(n) {
    if (n === 0) {
      return 0;
    }
    if (n <= 2) {
      return 1;
    }
    if (!this.memoizedValues[n]) {
      this.memoizedValues[n] = this.memoizedFibo(n - 1) + this.memoizedFibo(n - 2);
      log(this.memoizedValues);
    }
    return this.memoizedValues[n];
  };

  fib = new Fibonacci;

  log(fib.naiveFibo(6));

  log(fib.memoizedFibo(6));

  // Lazy Loading
  Bread = class Bread {
    constructor(breadType1) {
      this.breadType = breadType1;
      log(`Bread ${this.breadType} created`);
    }

  };

  Bakery = class Bakery {
    constructor(requiredBreads) {
      this.requiredBreads = [];
    }

  };

  Bakery.prototype.orderBreadType = function(breadType) {
    return this.requiredBreads.push(breadType);
  };

  Bakery.prototype.pickupBread = function(breadType) {
    var len3, m, ref;
    log(`Pickup of bread ${breadType} requested`);
    if (!this.breads) {
      this.createBreads();
    }
    ref = this.breads;
    for (m = 0, len3 = ref.length; m < len3; m++) {
      i = ref[m];
      if (i.breadType === breadType) {
        return i;
      }
    }
  };

  Bakery.prototype.createBreads = function() {
    var len3, m, ref, results1;
    this.breads = [];
    ref = this.requiredBreads;
    results1 = [];
    for (m = 0, len3 = ref.length; m < len3; m++) {
      i = ref[m];
      results1.push(this.breads.push(new Bread(i)));
    }
    return results1;
  };

  bakery = new Bakery;

  bakery.orderBreadType("Brioche");

  bakery.orderBreadType("Anadama bread");

  bakery.orderBreadType("Chapati");

  bakery.orderBreadType("Focaccia");

  // log bakery.reqiredBreads
  log(bakery.pickupBread("Brioche").breadType + "pickedup");

  // ****************************   PROMISE   *******************************************************
  amIHappy = true;

  willGetReward = new Promise(function(resolve, reject) {
    var phone, reason;
    if (amIHappy) {
      phone = {
        make: 'iPhone',
        model: 'X'
      };
      log(`I'll buy you ${phone.make} ${phone.model}`);
      return resolve(phone);
    } else {
      reason = new Error('I am not too happy');
      return reject(reason);
    }
  });

  // consuming promise
  askMe_1 = function() {
    return willGetReward.then(function(fulfilled) {
      return log(fulfilled);
    }).catch(function(err) {
      return log(err.message);
    });
  };

  askMe_1();

  showOff_1 = function(phone) {
    return new Promise(function(resolve, reject) {
      var message;
      message = `Hey friend I have a new ${phone.make} ${phone.model}`;
      return resolve(message);
    });
  };

  // We didn't call the reject. It's optional. We can shorten this sample like using Promise.resolve instead.
  showOff_2 = function(phone) {
    var message;
    message = `Hey friend I have a new ${phone.make} ${phone.model}`;
    return Promise.resolve(message);
  };

  askMe_2 = async function() {
    var err, message, phone;
    try {
      log('before asking 1');
      await (phone = willGetReward);
      await (message = showOff_2(phone));
      log(message);
      return log('after asking 1');
    } catch (error) {
      err = error;
      log(err.message);
      return log('after asking 2');
    }
  };

  (async() => {
    return (await askMe_2());
  })();

}).call(this);
